#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
Getopt::Long::Configure qw(no_ignore_case);
use File::Basename;
use FindBin qw($Bin);
use lib "$Bin/.Modules";
use Parameter::BinList;

my ($HelpFlag,$BinList,$BeginTime);
my $ThisScriptName = basename $0;
my ($Json,$StatFile,$RawPrefix,$CleanPrefix,$Rscript,$QCAssistBin);
my (@RawFq,@CleanFq);
my (@ReadLen,@ReadNum,@BaseA,@BaseT,@BaseC,@BaseG,@BaseN,@TotalQual,@QualDistr);
my $HelpInfo = <<USAGE;

 $ThisScriptName
 Auther: zhangdong_xie\@foxmail.com

  This script was used to calculate GC, ErrorRate, Adaptor Rate for fastq files.

 -json   ( Optional ) Json file generated by fastp;
 -stat   ( Optional ) File name of statistic items from json file (default: first item of json name sep by '.');
 -fq     ( Optional ) Raw fastq files (Multi times, like _R1.fq.gz and _R2.fq.gz);
 -prefix ( Optional ) Prefix for the raw files which will be added with '.GC'/'.GC.png','.QD'/'.QD.png','.QM'/'.QM.png','.Error.png' (default: first item of json name sep by '.');
 -Fq     ( Optional ) Clean fastq files (Multi times, like _R1.fq.gz and _R2.fq.gz);
 -Prefix ( Optional ) Prefix for the clean files which will be added with '.GC'/'.GC.png','.QD'/'.QD.png','.QM'/'.QM.png','.Error.png' (default: first item of json name sep by '.');

 -bin    List for searching of related bin or scripts;
 -h      Help infomation;

USAGE
die $HelpInfo unless(@ARGV > 0);

GetOptions(
	'json:s' => \$Json,
	'stat:s' => \$StatFile,
	'fq:s' => \@RawFq,
	'prefix:s' => \$RawPrefix,
	'Fq:s' => \@CleanFq,
	'Prefix:s' => \$CleanPrefix,
	'bin:s' => \$BinList,
	'h!' => \$HelpFlag
) or die $HelpInfo;

if($HelpFlag)
{
	die $HelpInfo;
}
else
{
	$BeginTime = ScriptBegin(0,$ThisScriptName);
	
	# 默认是双端测序，假如只指定了一个fq则默认是记录fq路径的文件，需要解读;
	if($#RawFq == 0)
	{
		my $tmp = `cat $RawFq[0]`;
		chomp $tmp;
		@RawFq = split /\t/, $tmp;
	}
	$BinList = BinListGet() unless($BinList);
	$QCAssistBin = BinSearch("QCAssistBin",$BinList);
	$Rscript = BinSearch("Rscript",$BinList);
}


if($Json || @RawFq || @CleanFq)
{
	if($Json)
	{
		my $Dir = dirname $Json;
		$StatFile = $Dir . "/" . &PrefixConfirm($Json) . ".stat" unless($StatFile);
		$Dir = dirname $StatFile;
		`mkdir -p $Dir` unless(-d $Dir);
		
		open(ST,"> $StatFile") or die $!;
		print ST "Type\tRaw data\tClean data\n";
		
		my ($RawReadsNum, $CleanReadsNum) = (&Item3Extract($Json,"summary","before_filtering","total_reads"),&Item3Extract($Json,"summary","after_filtering","total_reads"));
		my ($HalfRawReadsNum, $HalfCleanReadsNum) = (&Item2Extract($Json,"read1_before_filtering","total_reads"),&Item2Extract($Json,"read1_after_filtering","total_reads"));
		print ST "Number of Reads:\t$HalfRawReadsNum\t$HalfCleanReadsNum\n";
		
		my ($RawDataSize, $CleanDataSize) = (&Item3Extract($Json,"summary","before_filtering","total_bases"),&Item3Extract($Json,"summary","after_filtering","total_bases"));
		my $Per = "-";
		$Per = sprintf("%.2f",$CleanDataSize / $RawDataSize * 100) . "%" if($RawDataSize);
		print ST "Data Size:\t$RawDataSize\t$CleanDataSize($Per)\n";
		
		my ($RawNOfFq1, $CleanNOfFq1) = (&Items3MeanExtract($Json,"read1_before_filtering","content_curves","N"),&Items3MeanExtract($Json,"read1_after_filtering","content_curves","N"));
		$RawNOfFq1 = sprintf("%.2f",$RawNOfFq1 * 100) . "%";
		$CleanNOfFq1 = sprintf("%.2f",$CleanNOfFq1 * 100) . "%";
		print ST "N of fq1:\t$RawNOfFq1\t$CleanNOfFq1\n";
		
		my ($RawNOfFq2, $CleanNOfFq2) = (&Items3MeanExtract($Json,"read2_before_filtering","content_curves","N"),&Items3MeanExtract($Json,"read2_after_filtering","content_curves","N"));
		$RawNOfFq2 = sprintf("%.2f",$RawNOfFq2 * 100) . "%";
		$CleanNOfFq2 = sprintf("%.2f",$CleanNOfFq2 * 100) . "%";
		print ST "N of fq2:\t$RawNOfFq2\t$CleanNOfFq2\n";
		
		my ($RawLowQualOfFq1, $CleanLowQualOfFq1) = ("-","-");
		my ($RawBaseOfFq1,$CleanBaseOfFq1) = (&Item2Extract($Json,"read1_before_filtering","total_bases"),&Item2Extract($Json,"read1_after_filtering","total_bases"));
		$RawLowQualOfFq1 = &QualNumConfirm($RawFq[0],5,0) if($RawFq[0]);
		$RawLowQualOfFq1 = sprintf("%.2f",$RawLowQualOfFq1 / $RawBaseOfFq1 * 100) . "%" if($RawBaseOfFq1);
		$RawLowQualOfFq1 = "-" unless($RawBaseOfFq1);
		$CleanLowQualOfFq1 = &QualNumConfirm($CleanFq[0],5,1) if($CleanFq[0]);
		$CleanLowQualOfFq1 = sprintf("%.2f",$CleanLowQualOfFq1 / $CleanBaseOfFq1 * 100) . "%" if($CleanBaseOfFq1);
		$CleanLowQualOfFq1 = "-" unless($CleanLowQualOfFq1);
		print ST "Low qual base of fq1(<=5):\t$RawLowQualOfFq1\t$CleanLowQualOfFq1\n";
		
		my ($RawLowQualOfFq2, $CleanLowQualOfFq2) = ("-","-");
		my ($RawBaseOfFq2,$CleanBaseOfFq2) = (&Item2Extract($Json,"read2_before_filtering","total_bases"),&Item2Extract($Json,"read2_after_filtering","total_bases"));
		$RawLowQualOfFq2 = &QualNumConfirm($RawFq[1],5,2) if($RawFq[1]);
		$RawLowQualOfFq2 = sprintf("%.2f",$RawLowQualOfFq2 / $RawBaseOfFq2 * 100) . "%" if($RawBaseOfFq2);
		$RawLowQualOfFq2 = "-" unless($RawLowQualOfFq2);
		$CleanLowQualOfFq2 = &QualNumConfirm($CleanFq[1],5,3) if($CleanFq[1]);
		$CleanLowQualOfFq2 = sprintf("%.2f",$CleanLowQualOfFq2 / $CleanBaseOfFq2 * 100) . "%" if($CleanBaseOfFq2);
		$CleanLowQualOfFq2 = "-" unless($CleanLowQualOfFq2);
		print ST "Low qual base of fq2(<=5):\t$RawLowQualOfFq2\t$CleanLowQualOfFq2\n";
		
		my ($RawQ20BaseOfFq1,$CleanQ20BaseOfFq1) = (&Item2Extract($Json,"read1_before_filtering","q20_bases"),&Item2Extract($Json,"read1_after_filtering","q20_bases"));
		my ($RawQ20RateOfFq1,$CleanQ20RateOfFq1) = ("-","-");
		$RawQ20RateOfFq1 = sprintf("%.2f",$RawQ20BaseOfFq1 / $RawBaseOfFq1 * 100) . "%" if($RawBaseOfFq1);
		$CleanQ20RateOfFq1 = sprintf("%.2f",$CleanQ20BaseOfFq1 / $CleanBaseOfFq1 * 100) . "%" if($CleanBaseOfFq1);
		print ST "Q20 of fq1:\t$RawQ20RateOfFq1\t$CleanQ20RateOfFq1\n";
		
		my ($RawQ20BaseOfFq2,$CleanQ20BaseOfFq2) = (&Item2Extract($Json,"read2_before_filtering","q20_bases"),&Item2Extract($Json,"read2_after_filtering","q20_bases"));
		my ($RawQ20RateOfFq2,$CleanQ20RateOfFq2) = ("-","-");
		$RawQ20RateOfFq2 = sprintf("%.2f",$RawQ20BaseOfFq2 / $RawBaseOfFq2 * 100) . "%" if($RawBaseOfFq2);
		$CleanQ20RateOfFq2 = sprintf("%.2f",$CleanQ20BaseOfFq2 / $CleanBaseOfFq2 * 100) . "%" if($CleanBaseOfFq2);
		print ST "Q20 of fq2:\t$RawQ20RateOfFq2\t$CleanQ20RateOfFq2\n";
		
		my ($RawQ30BaseOfFq1,$CleanQ30BaseOfFq1) = (&Item2Extract($Json,"read1_before_filtering","q30_bases"),&Item2Extract($Json,"read1_after_filtering","q30_bases"));
		my ($RawQ30RateOfFq1,$CleanQ30RateOfFq1) = ("-","-");
		$RawQ30RateOfFq1 = sprintf("%.2f",$RawQ30BaseOfFq1 / $RawBaseOfFq1 * 100) . "%" if($RawBaseOfFq1);
		$CleanQ30RateOfFq1 = sprintf("%.2f",$CleanQ30BaseOfFq1 / $CleanBaseOfFq1 * 100) . "%" if($CleanBaseOfFq1);
		print ST "Q30 of fq1:\t$RawQ30RateOfFq1\t$CleanQ30RateOfFq1\n";
		
		my ($RawQ30BaseOfFq2,$CleanQ30BaseOfFq2) = (&Item2Extract($Json,"read2_before_filtering","q30_bases"),&Item2Extract($Json,"read2_after_filtering","q30_bases"));
		my ($RawQ30RateOfFq2,$CleanQ30RateOfFq2) = ("-","-");
		$RawQ30RateOfFq2 = sprintf("%.2f",$RawQ30BaseOfFq2 / $RawBaseOfFq2 * 100) . "%" if($RawBaseOfFq2);
		$CleanQ30RateOfFq2 = sprintf("%.2f",$CleanQ30BaseOfFq2 / $CleanBaseOfFq2 * 100) . "%" if($CleanBaseOfFq2);
		print ST "Q30 of fq2:\t$RawQ30RateOfFq2\t$CleanQ30RateOfFq2\n";
		
		my ($RawGCRateOfFq1,$CleanGCRateOfFq1) = (&Items3MeanExtract($Json,"read1_before_filtering","content_curves","GC"),&Items3MeanExtract($Json,"read1_after_filtering","content_curves","GC"));
		$RawGCRateOfFq1 = sprintf("%.2f",$RawGCRateOfFq1 * 100) . "%";
		$CleanGCRateOfFq1 = sprintf("%.2f",$CleanGCRateOfFq1 * 100) . "%";
		print ST "GC of fq1:\t$RawGCRateOfFq1\t$CleanGCRateOfFq1\n";
		
		my ($RawGCRateOfFq2,$CleanGCRateOfFq2) = (&Items3MeanExtract($Json,"read2_before_filtering","content_curves","GC"),&Items3MeanExtract($Json,"read2_after_filtering","content_curves","GC"));
		$RawGCRateOfFq2 = sprintf("%.2f",$RawGCRateOfFq2 * 100) . "%";
		$CleanGCRateOfFq2 = sprintf("%.2f",$CleanGCRateOfFq2 * 100) . "%";
		print ST "GC of fq2:\t$RawGCRateOfFq2\t$CleanGCRateOfFq2\n";
		
		my ($RawErrorRateOfFq1,$CleanErrorRateOfFq1) = (&Items3MeanExtract($Json,"read1_before_filtering","quality_curves","mean"),&Items3MeanExtract($Json,"read1_after_filtering","quality_curves","mean"));
		$RawErrorRateOfFq1 = 0 - $RawErrorRateOfFq1 / 10;
		$RawErrorRateOfFq1 = sprintf("%.2f",(10 ** $RawErrorRateOfFq1) * 100) . "%";
		$CleanErrorRateOfFq1 = 0 - $CleanErrorRateOfFq1 / 10;
		$CleanErrorRateOfFq1 = sprintf("%.2f",(10 ** $CleanErrorRateOfFq1) * 100) . "%";
		print ST "Error of fq1:\t$RawErrorRateOfFq1\t$CleanErrorRateOfFq1\n";
		
		my ($RawErrorRateOfFq2,$CleanErrorRateOfFq2) = (&Items3MeanExtract($Json,"read2_before_filtering","quality_curves","mean"),&Items3MeanExtract($Json,"read2_after_filtering","quality_curves","mean"));
		$RawErrorRateOfFq2 = 0 - $RawErrorRateOfFq2 / 10;
		$RawErrorRateOfFq2 = sprintf("%.2f",(10 ** $RawErrorRateOfFq2) * 100) . "%";
		$CleanErrorRateOfFq2 = 0 - $CleanErrorRateOfFq2 / 10;
		$CleanErrorRateOfFq2 = sprintf("%.2f",(10 ** $CleanErrorRateOfFq2) * 100) . "%";
		print ST "Error of fq2:\t$RawErrorRateOfFq2\t$CleanErrorRateOfFq2\n";
		
		my $DiscardReadsOfNAndLowQuality = &Item2Extract($Json,"filtering_result","too_many_N_reads") + &Item2Extract($Json,"filtering_result","low_quality_reads");
		my $DiscardRateOfNAndLowQuality = "-";
		$DiscardRateOfNAndLowQuality = sprintf("%.2f",$DiscardReadsOfNAndLowQuality / $RawReadsNum * 100) . "%" if($RawReadsNum);
		print ST "Discard Reads related to N and low qual:\t$DiscardRateOfNAndLowQuality\n";
		
		my $DiscardReadsOfAdaptor = &Item2Extract($Json,"filtering_result","too_short_reads") + &Item2Extract($Json,"filtering_result","too_long_reads");
		#my $DiscardRateOfAdaptor = "-";
		#$DiscardRateOfAdaptor = sprintf("%.2f",$DiscardReadsOfAdaptor / $RawReadsNum * 100) . "%" if($RawReadsNum);
		#print ST "Discard Reads related to Adapter:\t$DiscardRateOfAdaptor\n";
		$DiscardReadsOfAdaptor = $DiscardReadsOfAdaptor / 2;
		print ST "Discard Reads related to Adapter:\t$DiscardReadsOfAdaptor\n";
		
		close ST;
	}
	printf "[ %s ] Json file done.\n",TimeString(time,$BeginTime);
	
	if(@RawFq)
	{
		my $Dir = dirname $RawFq[0];
		$RawPrefix = $Dir . "/" . &PrefixConfirm($RawFq[0]) unless($RawPrefix);
		
		&FqStat($RawPrefix,0,2);
	}
	printf "[ %s ] Raw fastq done.\n",TimeString(time,$BeginTime);
	
	if(@CleanFq)
	{
		my $Dir = dirname $CleanFq[0];
		$CleanPrefix = $Dir . "/" . &PrefixConfirm($CleanFq[0]) unless($CleanPrefix);
		
		&FqStat($CleanPrefix,1,3);
	}
	printf "[ %s ] Clean fastq done.\n",TimeString(time,$BeginTime);
}
printf "[ %s ] The end.\n",TimeString(time,$BeginTime);


######### Sub functions ##########
sub PrefixConfirm
{
	my $File = $_[0];
	
	my $BaseName = basename $File;
	my @Cols = split /\./, $BaseName;
	
	return $Cols[0];
}

sub Item2Extract
{
	my ($json,$item1,$item2) = @_;
	
	my $content = `cat $json`;
	if($content =~ /\"$item1\":\s*([\d\D]+)/)
	{
		my $tmp = $1;
		$content = &PairTrunc($tmp);
		
		if($content =~ /\"$item2\":\s*([^,]+),/)
		{
			$tmp = $1;
			
			return $tmp;
		}
	}
	
	return 0;
}

sub Item3Extract
{
	my ($json,$item1,$item2,$item3) = @_;
	
	my $content = `cat $json`;
	if($content =~ /\"$item1\":\s*([\d\D]+)/)
	{
		my $tmp = $1;
		$content = &PairTrunc($tmp);
		
		if($content =~ /\"$item2\":\s*([\d\D]+)/)
		{
			$tmp = $1;
			$content = &PairTrunc($tmp);
			
			if($content =~ /\"$item3\":\s*([^,]+),/)
			{
				$tmp = $1;
				
				return $tmp;
			}
		}
	}
	
	return 0;
}

sub Items3MeanExtract
{
	my ($json,$item1,$item2,$item3) = @_;
	
	my $content = `cat $json`;
	if($content =~ /\"$item1\":\s*([\d\D]+)/)
	{
		my $tmp = $1;
		$content = &PairTrunc($tmp);
		
		if($content =~ /\"$item2\":\s*([\d\D]+)/)
		{
			$tmp = $1;
			$content = &PairTrunc($tmp);
			
			if($content =~ /\"$item3\":\s*\[([^\]]+)\]/)
			{
				my @cols = split /,/, $1;
				my $total = 0;
				my $num = @cols;
				for my $i (0 .. $#cols)
				{
					$total += $cols[$i];
				}
				my $mean = 0;
				$mean = sprintf("%.4f",$total / $num) if($num);
				
				return $mean;
			}
		}
	}
	
	return 0;
}

sub PairTrunc
{
	my $line = $_[0];
	
	my $flag = -1;
	my $num = 1;
	my @cols = split //, $line;
	for my $i (0 .. $#cols)
	{
		$num ++ if($cols[$i] eq "{");
		$num -- if($cols[$i] eq "}");
		
		if($num == 0)
		{
			$flag = $i - 1;
			last;
		}
	}
	my $tmp = "";
	$tmp = join("",@cols[0 .. $flag]) if($flag >= 0);
	
	return $tmp;
}

sub QualNumConfirm
{
	my ($file,$max,$id) = @_;
	
	my $Return = "";
	if($file =~ /fq.gz$/)
	{
		$Return = `zcat $file | $QCAssistBin`;
	}
	else
	{
		$Return = `cat $file | $QCAssistBin`;
	}
	
	chomp $Return;
	print "[ Statistic info for $file ]\n$Return\n";
	my @cols = split /\n/, $Return;
	for my $i (0 .. $#cols)
	{
		die "[ Error ] Incorrect result of $QCAssistBin .\n" if($cols[$i] =~ /Error/ || $cols[$i] !~ /^\[/);
	}
	
	my @subcols = split /\t/, $cols[0];
	$ReadNum[$id] = $subcols[1];
	
	@subcols = split /\t/, $cols[1];
	$ReadLen[$id] = $subcols[1];
	
	for my $i (2 .. $ReadLen[$id] + 1)
	{
		@subcols = split /\t/, $cols[$i];
		
		$BaseA[$id][$i - 2] = $subcols[2];
		$BaseT[$id][$i - 2] = $subcols[3];
		$BaseC[$id][$i - 2] = $subcols[4];
		$BaseG[$id][$i - 2] = $subcols[5];
		$BaseN[$id][$i - 2] = $subcols[6];
		$TotalQual[$id][$i - 2] = $subcols[7];
	}
	
	for my $i ($ReadLen[$id] + 2 .. $#cols)
	{
		@subcols = split /\t/, $cols[$i];
		
		$QualDistr[$id][$subcols[1]] = $subcols[2];
	}
	
	my $num = 0;
	for my $i (0 .. $max)
	{
		$num += $QualDistr[$id][$i];
	}
	
	return $num;
}

sub FqStat
{
	my @items = @_;
	my $pfix = $items[0];
	my @fqid = @items[1 .. $#items];
	
	my $Script = $pfix . ".R";
	my $GCData = $pfix . ".GC";
	my $GCMap = $pfix . ".GC.pdf";
	my $QDData = $pfix . ".QD";
	my $QDMap = $pfix . ".QD.pdf";
	my $QMData = $pfix . ".QM";
	my $QMMap = $pfix . ".QM.pdf";
	my $ErrorMap = $pfix . ".Error.pdf";
	
	my $accumid = 0;
	my (@BaseDistr,@QualStat,@QualSum) = ();
	for my $i (0 .. $#fqid)
	{
		my $id = $fqid[$i];
		
		for my $j (0 .. $ReadLen[$id] - 1)
		{
			$BaseDistr[$accumid][0] = $BaseA[$id][$j];
			$BaseDistr[$accumid][1] = $BaseT[$id][$j];
			$BaseDistr[$accumid][2] = $BaseC[$id][$j];
			$BaseDistr[$accumid][3] = $BaseG[$id][$j];
			$BaseDistr[$accumid][4] = $BaseN[$id][$j];
			$QualSum[$accumid] = $TotalQual[$id][$j];
			$accumid ++;
		}
		
		for my $j (0 .. $#{$QualDistr[$id]})
		{
			$QualStat[$j] += $QualDistr[$id][$j];
		}
	}
	
	
	# data;
	my @Num2Base = ('A','T','C','G','N');
	open(GC,"> $GCData") or die $!;
	for my $i (0 .. $#BaseDistr)
	{
		my $total = 0;
		for my $j (0 .. $#Num2Base)
		{
			$BaseDistr[$i][$j] = 0 unless($BaseDistr[$i][$j]);
			$total += $BaseDistr[$i][$j];
		}
		
		print GC "$i";
		for my $j (0 .. $#Num2Base)
		{
			print GC "\t$Num2Base[$j]\t$BaseDistr[$i][$j]\t",sprintf("%.2f",$BaseDistr[$i][$j] / $total * 100);
		}
		print GC "\n";
	}
	close GC;
	
	open(QD,"> $QDData") or die $!;
	for my $i (0 .. 66)
	{
		$QualStat[$i] = 0 unless($QualStat[$i]);
		
		print QD "$i\t$QualStat[$i]\n";
	}
	close QD;
	
	my $readnum = 0;
	for my $i (0 .. $#{$BaseDistr[0]})
	{
		$readnum += $BaseDistr[0][$i];
	}
	open(QM,"> $QMData") or die $!;
	for my $i (0 .. $#QualSum)
	{
		my $tqual = sprintf("%.6f",$QualSum[$i] / $readnum);
		my $trate = sprintf("%.6f",10 ** (0 - $tqual / 10));
		print QM "$i\t$tqual\t$trate\n";
	}
	close QM;
	
	
	# map;
	my $ReadLen = @BaseDistr;
	$ReadLen = int($ReadLen / 2);
	&ScriptGen($Script,$GCData,$GCMap,$QDData,$QDMap,$QMData,$QMMap,$ErrorMap,$ReadLen);
	
	`$Rscript $Script`;
	
	return 1;
}

sub ScriptGen
{
	my ($script,$data1,$map1,$data2,$map2,$data3,$map3,$map4,$len) = @_;
	
	open(SCR,"> $script") or die $!;
	print SCR "a<-read.table(\"$data1\")\n";
	print SCR "x<-a\[,1\]\n";
	print SCR "y<-a\[,4\]\n";
	#print SCR "png(\"$map1\",type=\"cairo\")\n";
	print SCR "pdf(\"$map1\")\n";
	print SCR "plot(x,y,xlim=c(0,(2\*",$len,"-1)),ylim=c(0,50),col=\"red\",type=\"l\",xlab=\"Position along reads\",ylab=\"percent\",main=\"Base percentage composition along reads\",lty=1,lwd=1.5)\n";
	print SCR "p<-a\[,7\]\n";
	print SCR "q<-a\[,10\]\n";
	print SCR "s<-a\[,13\]\n";
	print SCR "m<-a\[,16\]\n";
	print SCR "lines(x,p,col=\"magenta\",type=\"l\",lty=2,lwd=1.5)\n";
	print SCR "lines(x,q,col=\"darkblue\",type=\"l\",lty=4,lwd=1.5)\n";
	print SCR "lines(x,s,col=\"green\",type=\"l\",lty=5,lwd=1.5)\n";
	print SCR "lines(x,m,col=\"cyan3\",type=\"l\",lty=6,lwd=1.5)\n";
	print SCR "legend(\"topright\",legend=c(\"A\",\"T\",\"C\",\"G\",\"N\"),col=c(\"red\",\"magenta\",\"darkblue\",\"green\",\"cyan3\"),lty=c(1,2,4,5,6))\n";
	print SCR "abline(v=",$len,",col=\"darkblue\",lty=2)\n";
	print SCR "dev.off()\n";
	print SCR "\n";
	print SCR "a<-read.table(\"$data2\")\n";
	print SCR "x<-a\[,1\]\n";
	print SCR "y<-a\[,2\]\n";
	#print SCR "png(\"$map2\",type=\"cairo\")\n";
	print SCR "pdf(\"$map2\")\n";
	print SCR "plot(x,y,col=\"red\",type=\"l\",xlab=\"Quality score\",ylab=\"Number of bases\",main=\"Quality score distribution over all sequences\")\n";
	print SCR "axis(side=1,at=seq(from=0,to=max(x),by=5))\n";
	print SCR "dev.off()\n";
	print SCR "\n";
	print SCR "a<-read.table(\"$data3\")\n";
	print SCR "x<-a\[,1\]\n";
	print SCR "y<-a\[,2\]\n";
	print SCR "z<-a\[,3\]\n";
	#print SCR "png(\"$map3\",type=\"cairo\")\n";
	print SCR "pdf(\"$map3\")\n";
	print SCR "plot(x,y,xaxt=\"n\",xlim=c(0,(2\*",$len,"-1)),ylim=c(0,40),col=\"red\",type=\"p\",pch=\".\",cex=1.5,xlab=\"Position along reads\",ylab=\"Quality\",main=\"Qualities Distribution\")\n";
	print SCR "axis(side=1,at=seq(from=0,to=(2\*",$len,"-1),by=20))\n";
	my $loop = int($len / 20);
	$loop -- if($loop * 20 == $len);
	for my $i (1 .. $loop)
	{
		my $cut = $i * 20;
		print SCR "abline(h=$cut,col=\"darkblue\",lty=3)\n";
	}
	#print SCR "png(\"$map4\",type=\"cairo\")\n";
	print SCR "pdf(\"$map4\")\n";
	print SCR "plot(x,z,xaxt=\"n\",xlim=c(0,(2\*",$len,"-1)),col=\"red\",type=\"h\",xlab=\"Position along reads\",ylab=\"\% Error-Rate\")\n";
	print SCR "axis(side=1,at=seq(from=0,to=(2\*",$len,"-1),by=20))\n";
	for my $i (1 .. $loop)
	{
		my $cut = $i * 20;
		print SCR "abline(h=$cut,col=\"darkblue\",lty=3)\n";
	}
	print SCR "dev.off()\n";
	close SCR;
	
	return 1;
}